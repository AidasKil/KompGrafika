<!DOCTYPE html>

<html>

<head>
    <title>Example 01.02 - First Scene</title>
    <style>
        body{
            /* set margin to 0 and overflow to hidden, to go fullscreen */
            margin: 0;
            overflow: hidden;
        }
    </style>
</head>
<body>

<!-- Div which will hold the Output -->
<div id="WebGL-output">
</div>

<!-- Javascript code that runs our Three.js examples -->
<script type="module">
    
    import * as THREE from 'https://unpkg.com/three@0.119.0/build/three.module.js';
    import { OrbitControls } from 'https://unpkg.com/three@0.119.0/examples/jsm/controls/OrbitControls.js';
    //import 'https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js';
    //import 'https://cdn.jsdelivr.net/npm/three-orbitcontrols@2.110.3/OrbitControls.js';

    let camera, controls, scene, renderer;
    let useWireframe = true;

init();
//render(); // remove when using next line for animation loop (requestAnimationFrame)
animate();

function init() {

    scene = new THREE.Scene();
    scene.background = new THREE.Color( 0xcccccc );

    renderer = new THREE.WebGLRenderer( { antialias: true } );
    renderer.setPixelRatio( window.devicePixelRatio );
    renderer.setSize( window.innerWidth, window.innerHeight );
    document.body.appendChild( renderer.domElement );

    initCamera();
    
    var stepsCount = 100;
    var stepHeight = 1.75; // WIP: use this in RenderStep??? this is cylinder height + cube height
    
    var stepX = 0;
    var stepZ = 0;
    var rotation = Math.PI/9;
    var railingPositions = new Array(stepsCount);
    for(var i=0;i<stepsCount;i++)
        {
        // cia 1.5 yra to raudono ilgis - cilindro ilgis
        var xOffSet = (1.5*Math.cos(rotation*(i-1)));
        var zOffSet = (1.5*Math.sin(rotation*(i-1)));
        
        if(i < 2)
            {
            xOffSet = 0;
            zOffSet = 0;
            }
        var vector = new THREE.Vector3(0, 0,0);
        var axis = new THREE.Vector3(0, 1,0);
        if(i>=2)
            vector.applyAxisAngle(axis, rotation);
        else if(i==1)
            stepX -=1.5;
            
        stepZ = stepZ - zOffSet + vector.z;
        stepX = stepX - xOffSet + vector.x;
        railingPositions[i]=RenderStep(stepX, stepHeight *i, stepZ, i % 2 == 0, rotation*i);
        }

        var splineCurve = new THREE.SplineCurve3(railingPositions);
        var railingGeometry = new THREE.TubeGeometry(splineCurve, 5*stepsCount,.1,10, false);        
        var railingMaterial = new THREE.MeshBasicMaterial( {color: 0x0000FF, wireframe:useWireframe} );
        var railingMesh = new THREE.Mesh(railingGeometry, railingMaterial);
        
        scene.add(railingMesh);
    var axes = new THREE.AxesHelper( 20 );
    scene.add(axes);

    window.addEventListener( 'resize', onWindowResize, false );

}

function initCamera()
{
    camera = new THREE.PerspectiveCamera( 60, window.innerWidth / window.innerHeight, 1, 1000 );
    camera.position.set( 40, 40, 0 );

    // controls

    controls = new OrbitControls( camera, renderer.domElement );

    //controls.addEventListener( 'change', render ); // call this only in static scenes (i.e., if there is no animation loop)

    controls.enableDamping = true; // an animation loop is required when either damping or auto-rotation are enabled
    controls.dampingFactor = 0.05;

    controls.screenSpacePanning = false;

    controls.minDistance = 1;
    controls.maxDistance = 500;

    controls.maxPolarAngle = Math.PI / 2;
}

function onWindowResize() {

    camera.aspect = window.innerWidth / window.innerHeight;
    camera.updateProjectionMatrix();

    renderer.setSize( window.innerWidth, window.innerHeight );

}

function animate() {

    requestAnimationFrame( animate );

    controls.update(); // only required if controls.enableDamping = true, or if controls.autoRotate = true

    render();

}

function render() {

    renderer.render( scene, camera );

}
    function RenderStep(x, y, z, isLeftStep, rotation)
    {
        var shape = new THREE.Shape();
        shape.moveTo(0,-3);
        shape.lineTo(0, 3);
        shape.lineTo(.5, 3);
        shape.bezierCurveTo(1, 0.2, 2, 0, 2,0);
        shape.lineTo(2, -3);
        shape.lineTo(0, -3);

        var depth = .25;

        var extrudeSettings = {
        steps: 2,
        depth: depth,
        bevelEnabled: true,
        bevelThickness: .1,
        bevelSize: .1,
        bevelOffset: 0,
        bevelSegments: 3
        };

        var geometry = new THREE.ExtrudeGeometry( shape, extrudeSettings );
        var material = new THREE.MeshBasicMaterial( { color: 0xa0522d, wireframe: useWireframe } );
        var stepMesh = new THREE.Mesh( geometry, material ) ;

        var cylinderHeight = 1.5;
        var cylinderRadius = .25;
        var cylGeometry = new THREE.CylinderGeometry(cylinderRadius, cylinderRadius, cylinderHeight, 32);
        var cylMaterial = new THREE.MeshBasicMaterial( {color: 0x808080, wireframe:useWireframe} );
        var cylinderMesh = new THREE.Mesh(cylGeometry, cylMaterial);

        var cubeHeight = .25;
        var cubeLength = 2;
        var cubeGeometry = new THREE.CubeGeometry(cubeLength, cubeHeight, .5);
        var cubeMaterial = new THREE.MeshBasicMaterial( {color: 0xFF0000, wireframe:useWireframe} );
        var cubeMesh = new THREE.Mesh(cubeGeometry, cubeMaterial);

            
        var radius = (cubeLength - cylinderRadius*2)/2;
        var xOffset = radius *Math.cos(rotation);
        var zOffset = radius * Math.sin(rotation);

        cylinderMesh.position.x = x;// + xOffset;// + vector.x;
        cylinderMesh.position.y = y + cylinderHeight/2;// + vector.y;
        cylinderMesh.position.z = z;// + zOffset;// + vector.z;

        
        cubeMesh.position.x = x - xOffset;
        cubeMesh.position.y = y + cylinderHeight + cubeHeight/2;
        cubeMesh.position.z = z - zOffset;
        cubeMesh.rotation.y = -rotation;

        stepMesh.position.x = x - xOffset;
        stepMesh.position.y = y + cylinderHeight + cubeHeight + depth;
        stepMesh.position.z = z - zOffset;
        stepMesh.rotation.x = Math.PI/2;
        stepMesh.rotation.z = rotation;

        var splineCurve = new THREE.SplineCurve3([
            new THREE.Vector3(0,0,0),
            new THREE.Vector3(0,-cubeHeight/2,0),
            new THREE.Vector3(0,-cubeHeight/2,+3.5),
            new THREE.Vector3(0,8,3.5),
        ]);


        var railingGeometry = new THREE.TubeGeometry(splineCurve, 64,.1,10, false);        
        var railingMaterial = new THREE.MeshBasicMaterial( {color: 0x00FF00, wireframe:useWireframe} );
        var railingMesh = new THREE.Mesh(railingGeometry, railingMaterial);

        railingMesh.position.set(x-xOffset,y+cylinderHeight,z-zOffset);
        railingMesh.rotation.y = -rotation;

        scene.add(railingMesh);

        if(isLeftStep)
            stepMesh.scale.y = -1;

        scene.add(stepMesh);
        scene.add(cubeMesh);
        scene.add(cylinderMesh);

        var vector =  new THREE.Vector3(0,8,3.5);
        vector.applyAxisAngle( new THREE.Vector3(0,1,0), -rotation);
        vector.add(railingMesh.position);
        return vector;
    }

</script>
</body>
</html>